(defpackage fcl.adata
  (:nicknames :fcl.core.adata :fcl.dt)
  (:use :common-lisp :fcl.adata.util :fcl.adata.parser)
  (:import-from :fcl.util #:length= #:rpartial #:proper-list)
  (:import-from :fcl.lazy #:promise #:force)
  (:export
    #:algebraic-datatype
    #:defdata
    #:data=))
(in-package :fcl.adata)

(defstruct (algebraic-datatype (:constructor nil)
                               (:copier nil)
                               (:predicate nil)))

(defmacro defdata (name &body constructors)
  "A macro to define structures as algebraic datatypes."
  (every (lambda (constructor)
           (check-type constructor proper-list))
         constructors)
  `(progn
     (defstruct (,name (:constructor nil)
                       (:copier nil)
                       (:include algebraic-datatype)
                       (:predicate nil)))
     ,@(mapcar (rpartial #'parse-constructor name)
               constructors)
     ,@(mapcar #'parse-printer constructors)
     ',name))

(defgeneric data= (data1 data2)
  (:method ((data1 t) (data2 t))
   (equal data1 data2))
  (:method ((data1 symbol) (data2 symbol))
   (eq data1 data2))
  (:method ((data1 number) (data2 number))
   (= data1 data2))
  (:method ((data1 character) (data2 character))
   (char= data1 data2))
  (:method ((data1 string) (data2 string))
   (string= data1 data2))
  (:method ((data1 sequence) (data2 sequence))
   (and (length= data1 data2)
        (every #'data= data1 data2)))
  (:method ((data1 promise) (data2 promise))
   (data= (force data1) (force data2)))
  (:method ((data1 algebraic-datatype) (data2 algebraic-datatype))
   (every (lambda (p1 p2) (data= (slot-value data1 p1) (slot-value data2 p2)))
          (make-parameters (slot-value data1 'arity))
          (make-parameters (slot-value data2 'arity)))))
